buildscript {
    repositories {
        mavenLocal()
        try {
            maven {
                url "$repository"
            }
        }catch(Exception e) {
            maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
        }
        try {
            ivy {
                url "$repository"
                layout "maven"
            }
        }catch(Exception e) {
            maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
        }
    }
    dependencies{
        classpath "io.codearte.gradle.nexus:gradle-nexus-staging-plugin:0.5.3"
        classpath "com.github.jengelman.gradle.plugins:shadow:1.2.3"
    }
}

plugins {
    id 'net.researchgate.release' version '2.4.0'
}

apply plugin: 'idea'
apply plugin: 'java'
apply plugin: 'maven'
apply plugin: 'signing'
apply plugin: 'com.github.johnrengelman.shadow'
apply plugin: 'jacoco'
apply plugin: 'io.codearte.nexus-staging'

archivesBaseName='rest-storage'

if (!project.hasProperty('repoUsername')) {
    ext.repoUsername = 'randomUsername'
} else {
    println 'got property repoUsername: ' + repoUsername
}

if (!project.hasProperty('repoPassword')) {
    ext.repoPassword = 'randomPassword'
} else {
    //println 'got property repoPassword: ' + repoPassword
}

if(!project.hasProperty('uploadRepository')) {
    ext.uploadRepository = 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
} else {
    //println 'found custom uploadRepository: ' + uploadRepository
}

if(!project.hasProperty('snapshotRepository')) {
    ext.snapshotRepository = 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
} else {
    println 'found custom snapshotRepository: ' + snapshotRepository
}

repositories {
    mavenLocal()
    try {
        maven { url "$repository" }
        println 'use custom repository: ' + "$repository"
    } catch(Exception e) {
        maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
    }
    mavenCentral()
}

dependencies {
    compile "io.vertx:vertx-core:$vertxVersion"
    compile "io.vertx:vertx-redis-client:$vertxVersion"
    compile "io.vertx:vertx-web:$vertxVersion"
    compile "commons-lang:commons-lang:$commonslangVersion"
    compile "commons-codec:commons-codec:$commonscodecVersion"
    compile "org.hamcrest:hamcrest-core:1.3"

    runtime "commons-lang:commons-lang:$commonslangVersion"
    runtime "commons-codec:commons-codec:$commonscodecVersion"
    runtime "org.hamcrest:hamcrest-core:1.3"

    testCompile "redis.clients:jedis:$jedisVersion"
    testCompile "junit:junit:$junitVersion"
    testCompile "io.vertx:vertx-unit:$vertxVersion"
    testCompile "com.github.kstyrc:embedded-redis:0.6"
    testCompile "com.jayway.restassured:rest-assured:2.4.1"
    testCompile "org.springframework:spring-context:4.1.0.RELEASE"
    testCompile "org.springframework:spring-jdbc:4.1.0.RELEASE"
    testCompile "com.jayway.awaitility:awaitility:$awaitilityVersion"

    testRuntime 'com.github.kstyrc:embedded-redis:0.6'
}

ext.uploadToMavenCentral = false
ext.InstallOrUpload = false
gradle.taskGraph.whenReady { taskGraph ->
    if (taskGraph.hasTask(uploadArchives) || taskGraph.hasTask(install)) {
        ext.InstallOrUpload = true
    }
    if (taskGraph.hasTask(uploadArchives)) {
        println "InstallOrUpload: true"
        if ("$uploadRepository".toLowerCase().contains("sonatype")  && "$snapshotRepository".toLowerCase().contains("sonatype")) {
            println "uploadToMavenCentral: true"
            ext.uploadToMavenCentral = true
        }
    }
}

allprojects {
    tasks.withType(JavaCompile) {
        options.encoding = 'UTF-8'
    }

    tasks.withType(Test) {
        systemProperty "file.encoding", "UTF-8"
    }
}

task sourceJar(type: Jar) {
    description = 'Builds a source jar artifact suitable for maven deployment.'
    classifier = 'sources'
    from sourceSets.main.java
}
sourceJar.onlyIf { InstallOrUpload }

compileJava {
    options.encoding = "UTF-8"
}

javadoc {
    options.encoding = "UTF-8"
    classpath = configurations.compile
}
javadoc.onlyIf { InstallOrUpload }

task javadocJar(type: Jar) {
    description = 'Builds a javadoc jar artifact suitable for maven deployment.'
    classifier = 'javadoc'
    from javadoc.destinationDir
}
javadocJar.dependsOn javadoc
javadocJar.onlyIf { InstallOrUpload }

uploadArchives.dependsOn sourceJar, javadocJar

shadowJar {
    manifest {
        attributes 'Main-Class': 'io.vertx.core.Starter'
        attributes 'Main-Verticle': 'org.swisspush.reststorage.RestStorageMod'
    }
}

artifacts {
    archives jar, sourceJar, javadocJar, shadowJar
}

signing {
    required { uploadToMavenCentral }
    sign configurations.archives
}

test {
    testLogging {
        // set options for log level LIFECYCLE
        events "started", "passed", "skipped", "failed"
        exceptionFormat "full"

        // set options for log level QUIET
        quiet {
            events "started", "passed", "skipped", "failed"
            exceptionFormat "full"
        }

        // remove standard output/error logging from --info builds
        // by assigning only 'failed' and 'skipped' events
        info.events = ["failed", "skipped"]

        afterSuite { desc, result ->
            if (!desc.parent) { // will match the outermost suite
                def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
                def startItem = '|  ', endItem = '  |'
                def repeatLength = startItem.length() + output.length() + endItem.length()
                println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
            }
        }
    }
}

jacocoTestReport {
	reports {
		xml.enabled true
		html.enabled false
	}
}

uploadArchives {
    group 'build'
    description = "Does a maven deploy of archives artifacts"

    repositories {
        mavenDeployer {

            def snapRepository = project.hasProperty('snapshotRepository') ? project.getProperties().get('snapshotRepository') : null
            def relRepository = project.hasProperty('uploadRepository') ? project.getProperties().get('uploadRepository') : null
            def repoUsername = project.hasProperty('repoUsername') ? project.getProperties().get('repoUsername') : null
            def repoPassword = project.hasProperty('repoPassword') ? project.getProperties().get('repoPassword') : null

            configuration = configurations.archives

            if ( repoUsername == null || repoPassword == null || repoUsername == 'randomUsername' || repoPassword == 'randomPassword') {
                repository(url: relRepository)
                snapshotRepository(url: snapRepository)
            }
            else {
                repository(url: relRepository) {
                    authentication(userName: repoUsername, password: repoPassword)
                    if (project.hasProperty('proxyHost')) {
                        proxy(host: project.property('proxyHost'), port: Integer.valueOf(project.property('proxyPort')), type: 'https')
                    }
                }

                snapshotRepository(url: snapRepository) {
                    authentication(userName: repoUsername, password: repoPassword)
                    if (project.hasProperty('proxyHost')) {
                        proxy(host: project.property('proxyHost'), port: Integer.valueOf(project.property('proxyPort')), type: 'https')
                    }
                }
            }

            println " > should I sign poms ..."
            if (relRepository.toLowerCase().contains("sonatype") && snapRepository.toLowerCase().contains("sonatype")) {
                println " > signing poms ..."
                beforeDeployment { org.gradle.api.artifacts.maven.MavenDeployment deployment -> signing.signPom(deployment) }
            }

            configurePom(pom)
        }
    }
}

release {
    failOnCommitNeeded = true
    failOnPublishNeeded = true
    failOnSnapshotDependencies = true
    failOnUnversionedFiles = false
    failOnUpdateNeeded = true
    revertOnFail = true
    preTagCommitMessage = '[Gradle Release Plugin] - pre tag commit: '
    tagCommitMessage = '[Gradle Release Plugin] - creating tag: '
    newVersionCommitMessage = '[Gradle Release Plugin] - new version commit: '
    versionPropertyFile = 'gradle.properties'
    buildTasks = ['build']
    tagTemplate = 'v$version'
    scmAdapters = [
            net.researchgate.release.GitAdapter
    ]
    git {
        requireBranch = 'master'
        pushToRemote = 'origin'
    }
}
afterReleaseBuild.dependsOn uploadArchives

nexusStaging {
    packageGroup = "org.swisspush.reststorage"
}

def configurePom(def pom) {
    pom.project {
        name 'rest-storage'
        description 'Persistence for REST resources in the filesystem or a redis database'
        inceptionYear '2016'
        packaging 'jar'
        url 'https://github.com/swisspush/vertx-rest-storage'

        developers {
            developer {
                id 'floriankammermann'
                name 'Florian Kammermann'
                url 'https://github.com/floriankammermann'
            }
            developer {
                id 'mcweba'
                name 'Marc-Andre Weber'
                url 'https://github.com/mcweba'
            }
        }

        scm {
            url 'https://github.com/swisspush/vertx-rest-storage.git'
        }

        licenses {
            license {
                name 'The Apache Software License, Version 2.0'
                url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                distribution 'repo'
            }
        }

        properties {
            setProperty('project.build.sourceEncoding', 'UTF8')
        }
    }
}

